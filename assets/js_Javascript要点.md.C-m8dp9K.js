import{_ as a,c as i,o as l,a2 as e}from"./chunks/framework.DS0qWYV_.js";const f=JSON.parse('{"title":"Javascript 要点","description":"","frontmatter":{},"headers":[],"relativePath":"js/Javascript要点.md","filePath":"js/Javascript要点.md"}'),t={name:"js/Javascript要点.md"},r=e('<h1 id="javascript-要点" tabindex="-1">Javascript 要点 <a class="header-anchor" href="#javascript-要点" aria-label="Permalink to &quot;Javascript 要点&quot;">​</a></h1><h2 id="_1-数组" tabindex="-1">1. 数组 <a class="header-anchor" href="#_1-数组" aria-label="Permalink to &quot;1. 数组&quot;">​</a></h2><h3 id="_1-1-重要函数以及注意事项" tabindex="-1">1.1 重要函数以及注意事项 <a class="header-anchor" href="#_1-1-重要函数以及注意事项" aria-label="Permalink to &quot;1.1 重要函数以及注意事项&quot;">​</a></h3><ul><li>sort默认会按字母顺序排序</li><li>concat默认会打平数组,搭配Symbol.isConcatSpreadable可以选择是否强制打平</li><li>虽然<code>{}!={}</code>,但是在数组中，可以用includes,indexOf,lastIndexOf中严格相等进行查找</li><li>数组去重 <ul><li>方法一: 利用Set</li><li>方法二: 利用filter</li><li>方法三: 利用reduce</li></ul></li><li>数组扁平化 <ul><li>方法一: 利用reduce</li><li>方法二: 利用flat</li><li>方法三: 利用递归</li></ul></li></ul><h3 id="_1-2-数组方法" tabindex="-1">1.2 数组方法 <a class="header-anchor" href="#_1-2-数组方法" aria-label="Permalink to &quot;1.2 数组方法&quot;">​</a></h3><ul><li>forEach</li><li>map</li><li>filter</li><li>some</li><li>every</li><li>reduce</li><li>find</li><li>findIndex</li></ul>',6),c=[r];function o(s,n,d,_,h,u){return l(),i("div",null,c)}const m=a(t,[["render",o]]);export{f as __pageData,m as default};
